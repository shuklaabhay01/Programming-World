<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vertex Consultancy | Web, App & Software Development</title>
    <link rel="stylesheet" href="../css/c.css">
    <link rel="stylesheet" href="../css/style.css">



</head>

<body>

    <!-- ===== HEADER ===== -->
    <header>
        <div class="container">
            <h1 class="logo">Programming World</h1>
            <div class="nav-search-container">
                <li class="nav-search">
                    <div class="search-box">
                        <input type="text" id="navSearch" placeholder="Search language...">
                        <button id="searchBtn">üîç</button>
                    </div>
                </li>


                <nav>
                    <ul class="navbar">
                        <li><a href="index.html">Home</a></li>

                        <li class="dropdown">
                            <a href="#" class="dropdown-toggle">Languages‚ñæ</a>
                            <ul class="dropdown-menu">
                                <li><a href="services.html#web-development">C/C++/C#</a></li>
                                <li><a href="services.html#software-development">Python</a></li>
                                <li><a href="services.html#software-development">Java</a></li>
                                <li><a href="services.html#software-development">HTML/CSS/JavaScript</a></li>
                                <li><a href="services.html#web-development">kotlin</a></li>
                                <li><a href="services.html#web-development">PHP</a></li>
                                <li><a href="services.html#web-development">OCaml</a></li>
                                <li><a href="services.html#web-development">VB</a></li>
                                <li><a href="services.html#web-development">Ruby</a></li>
                                <li><a href="services.html#web-development">Perl</a></li>
                                <li><a href="services.html#web-development">Pascal</a></li>
                                <li><a href="services.html#web-development">Cobol</a></li>
                                <li><a href="services.html#web-development">R</a></li>
                                <li><a href="services.html#web-development">Fortron</a></li>
                                <li><a href="services.html#web-development">Haskel</a></li>
                                <li><a href="services.html#web-development">Assembly GCC</a></li>
                                <li><a href="services.html#web-development">Prolog</a></li>
                                <li><a href="services.html#web-development">Swift</a></li>
                                <li><a href="services.html#web-development">Rust</a></li>
                                <li><a href="services.html#web-development">Go</a></li>
                                <li><a href="services.html#web-development">Base</a></li>
                                <li><a href="services.html">all services</a></li>
                            </ul>
                        </li>

                        <li><a href="#why-us">Why Choose Us</a></li>
                        <li><a href="#about">About</a></li>
                        <li><a href="#testimonials">Testimonials</a></li>
                        <li><a href="contact.html">Contact</a></li>
                    </ul>
                </nav>
            </div>
        </div>
    </header>


    <section class="about-course">
        <h2>what is C language</h2>

        <p>
            "C" most commonly refers to the C programming language, a powerful, general-purpose language created by
            Dennis Ritchie in 1972, known for its efficiency, low-level memory access, and influence on many other
            languages (like C++, Java, C#). It's used for systems programming (UNIX, Linux kernel), applications, and
            embedded systems, balancing high-level control with hardware interaction, making it fast and versatile,
            though it requires manual memory management.

        </p>
        <p>Here is a **long definition of the C programming language**, written in clear, school-friendly language:

            **The C programming language** is a general-purpose, procedural programming language that was developed in
            the early 1970s by Dennis Ritchie at Bell Laboratories. It was originally created to develop system
            software, especially operating systems, and it became widely popular because of its efficiency, flexibility,
            and close relationship with computer hardware. C allows programmers to write programs that run very fast and
            use system resources efficiently, which makes it ideal for tasks where performance and control over memory
            are important.

            C is considered a **middle-level language** because it combines features of both high-level and low-level
            programming languages. Like high-level languages, it supports structured programming using functions, loops,
            and conditionals, making programs easier to understand and maintain. At the same time, like low-level
            languages, C provides direct access to memory through pointers and allows manipulation of bits and bytes,
            giving programmers fine control over how data is stored and processed in the computer.

            One of the most important characteristics of C is its **portability**. Programs written in C can be compiled
            and run on many different types of computers with little or no modification, as long as a suitable compiler
            is available. This feature has made C a foundation for many modern programming languages, such as C++, Java,
            and Python, and a popular choice for developing compilers, databases, embedded systems, and
            performance-critical applications.

            Overall, the C programming language is a powerful and foundational language that plays a major role in
            computer science education and software development. Learning C helps programmers understand core
            programming concepts, memory management, and how software interacts with hardware, making it an essential
            language for building strong programming skills.
        </p>
    </section>


    <section class="about-course">
        <h3>brief knowledge of C Programming</h3>
        <p>C is a general-purpose programming language. It was created in the 1970s by Dennis Ritchie and remains widely
            used and influential. By design, C gives the programmer relatively direct access to the features of the
            typical CPU architecture, customized for the target instruction set. It has been and continues to be used to
            implement operating systems (especially kernels[10]), device drivers, and protocol stacks, but its use in
            application software has been decreasing.[11] C is used on computers that range from the largest
            supercomputers to the smallest microcontrollers and embedded systems.

            A successor to the programming language B, C was originally developed at Bell Labs by Ritchie between 1972
            and 1973 to construct utilities running on Unix. It was applied to re-implementing the kernel of the Unix
            operating system.[12] During the 1980s, C gradually gained popularity. It has become one of the most widely
            used programming languages,[13][14] with C compilers available for practically all modern computer
            architectures and operating systems. The book The C Programming Language, co-authored by the original
            language designer, served for many years as the de facto standard for the language.[15][1] C has been
            standardized since 1989 by the American National Standards Institute (ANSI) and, subsequently, jointly by
            the International Organization for Standardization (ISO) and the International Electrotechnical Commission
            (IEC).

            C is an imperative procedural language, supporting structured programming, lexical variable scope, and
            recursion, with a static type system. It was designed to be compiled to provide low-level access to memory
            and language constructs that map efficiently to machine instructions, all with minimal runtime support.
            Despite its low-level capabilities, the language was designed to encourage cross-platform programming. A
            standards-compliant C program written with portability in mind can be compiled for a wide variety of
            computer platforms and operating systems with few changes to its source code.

            Although neither C nor its standard library provide some popular features found in other languages, it is
            flexible enough to support them. For example, object orientation and garbage collection are provided by
            external libraries GLib Object System and Boehm garbage collector, respectively.

            Since 2000, C has typically ranked as the most or second-most popular language in the TIOBE index.[16]
        </p>
    </section>
    <section class="about-course">
        <h3>characteristics of C Programming</h3>
        <ul>
            <li>Fast execution and memory control</li>
            <li>Foundation of modern programming</li>
            <li>Used in embedded and system software</li>
            <li>Free-form source code</li>
            <li>Semicolons terminate statement</li>
            <li>Curly braces group statements into blocks</li>
            <li>Executable code is contained in functions; no script-like syntax</li>
            <li>Parameters are passed by value; pass by-reference is achieved by passing a pointer to a value</li>
            <li>Relatively small number of keywords</li>
            <li>Control flow constructs, including if, for, do, while, and switch</li>
            <li>Arithmetic, bitwise, and logic operators, including +,+=,++,&,||</li>
            <li>Multiple assignments may be performed in a single statement</li>
            <li>User-defined identifiers are not distinguished from keywords; i.e. by a sigil</li>
            <li>A variable declared inside a block is accessible only in that block and only below the declaration</li>
            <li>A function return value can be ignored</li>
            <li>A function cannot be nested inside a function, but some translators support this</li>
            <li>Run-time polymorphism may be achieved using function pointers</li>
            <li>Supports recursionData typing is static, but weakly enforced; all variables have a type, but implicit
                conversion between primitive types weakens the separation of the different types</li>
            <li>User-defined data types allow for aliasing a data type specifier</li>
            <li>Syntax for array definition and access is via square bracket notation, for example month[11]. Indexing
                is defined in terms of pointer arithmetic. Whole arrays cannot be copied or compared without custom
                orlibrary code</li>
            <li>User-defined structure types allow related data elements to be passed and copied as a unit although two
                structures cannot be compared without custom code to compare each field</li>
            <li>User-defined union types support overlapping members; allowing multiple data types to share the
                samememory location</li>
            <li>User-defined enumeration types support aliasing integer values</li>
            <li>Lacks a string type but has syntax for null-terminated strings with associated handling in its standard
                library</li>
            <li>Supports low-level access to computer memory via pointers</li>
            <li>Supports procedure-like construct as a function returning void</li>
            <li>Supports dynamic memory via standard library functions</li>
            <li>Includes the C preprocessor to perform macro definition, source code file inclusion, and conditional
                compilation</li>
            <li>Supports modularity in that files are processed separately, with visibility control via static and
                extern attributes</li>
            <li>Minimized functionality in the core language while relatively complex functionality such as I/O, string
                manipulation, and mathematical functions supported via standard library functions</li>
            <li>Resulting compiled code has relatively straightforward needs on the underlying platform, making it
                desirable for operating and embedded systems</li>
        </ul>
    </section>
    <section class="about-course">
        <h3>Write the program</h3>
        <p>The original version was:
            main()
            {
            printf("hello, world\n");
            }
        </p>

        <p>A more modern version is:[d]

            #include <stdio.h>

                int main(void)
                {
                printf("hello, world\n");
                }</p>

        <hr>
        <p>The next code line declares the entry point function main. The run-time environment calls this function to
            begin program execution. The type specifier int indicates that the function returns an integer value. The
            void parameter list indicates that the function consumes no arguments. The run-time environment actually
            passes two arguments (typed int and char *[]), but this implementation ignores them. The ISO C standard
            (section 5.1.2.2.1) requires syntax that either is void or these two arguments ‚Äì a special treatment not
            afforded to other functions.</p>
        <hr>
        <p>The opening curly brace indicates the beginning of the code that defines the function.

            The next line of code calls (diverts execution to) the C standard library function printf with the address
            of the first character of a null-terminated string specified as a string literal. The text \n is an escape
            sequence that denotes the newline character which when output in a terminal results in moving the cursor to
            the beginning of the next line. Even though printf returns an int value, it is silently discarded. The
            semicolon ; terminates the call statement.

            The closing curly brace indicates the end of the main function. Prior to C99, an explicit return 0;
            statement was required at the end of main function, but since C99, the main function (as being the initial
            function call) implicitly returns 0 upon reaching its final closing curly brace</p>
    </section>
    <section class="about-course">
        <h3>History of C Language</h3>
        <p><b>Early developments</b>
            The origin of C is closely tied to the development of the Unix operating system, originally implemented in
            assembly language on a PDP-7 by Dennis Ritchie and Ken Thompson, incorporating several ideas from
            colleagues. Eventually, they decided to port the operating system to a PDP-11. The original PDP-11 version
            of Unix was also developed in assembly language.

            In 1970, Ritchie began developing C as an evolution of the B programming language, which itself was
            influenced by BCPL. The initial version of C was created to facilitate the development of the Unix operating
            system on the PDP-11. The first edition of Unix, released in 1971, included a C compiler, and by 1973, the
            entire Unix operating system was rewritten in C.

            <b>Standardization and growth</b>
            In 1983, the American National Standards Institute (ANSI) formed a committee to establish a standard
            specification for C, resulting in the publication of the ANSI C standard in 1989 (known as C89). This
            standardization helped ensure portability and consistency across different compilers and platforms.

            The International Organization for Standardization (ISO) adopted the ANSI C standard in 1990, leading to
            further refinements and updates over the years. Notable revisions include C99, which introduced several new
            features such as inline functions, variable-length arrays, and improved support for floating-point
            arithmetic.

            <b>Legacy and influence</b>
            C has had a profound impact on many subsequent programming languages, including C++, Objective-C, C#, Java,
            and others. Its design principles, such as low-level memory access and efficiency, have made it a popular
            choice for system programming, embedded systems, and performance-critical applications.

            Today, C remains widely used in various domains, from operating systems and compilers to game development
            and embedded systems. Its enduring popularity is a testament to its versatility and effectiveness as a
            programming language.
        </p>
        <hr>
        <p>Main article: B (programming language)
            Thompson wanted a programming language for developing utilities for the new platform. He first tried writing
            a Fortran compiler, but he soon gave up the idea and instead created a cut-down version of the recently
            developed systems programming language called BCPL. The official description of BCPL was not available at
            the time,[19] and Thompson modified the syntax to be less 'wordy' and similar to a simplified ALGOL known as
            SMALGOL.[20] He called the result B,[12] describing it as "BCPL semantics with a lot of SMALGOL syntax".[20]
            Like BCPL, B had a bootstrapping compiler to facilitate porting to new machines.[20] Ultimately, few
            utilities were written in B because it was too slow and could not take advantage of PDP-11 features such as
            byte addressability.

            Unlike BCPL's // comment marking comments up to the end of the line, B adopted /* comment */ as the comment
            delimiter, more akin to PL/1, and allowing comments to appear in the middle of lines. (BCPL's comment style
            would be reintroduced in C++.)[12]</p>
        <hr>
        <p><b>New B and first C release</b>
            In 1971 Ritchie started to improve B, to use the features of the more-powerful PDP-11. A significant
            addition was a character data type. He called this New B (NB).[20] Thompson started to use NB to write the
            Unix kernel, and his requirements shaped the direction of the language development.[20][21]

            Through to 1972, richer types were added to the NB language. NB had arrays of int and char, and to these
            types were added pointers, the ability to generate pointers to other types, arrays of all types, and types
            to be returned from functions. Arrays within expressions were effectively treated as pointers. A new
            compiler was written, and the language was renamed C.[12]

            The C compiler and some utilities made with it were included in Version 2 Unix, which is also known as
            Research Unix</p>
        <hr>
        <p><b>Structures and Unix kernel re-writeb </b>
            At Version 4 Unix, released in November 1973, the Unix kernel was extensively re-implemented in C.[12] By
            this time, the C language had acquired some powerful features such as struct types.

            The preprocessor was introduced around 1973 at the urging of Alan Snyder and also in recognition of the
            usefulness of the file-inclusion mechanisms available in BCPL and PL/I. Its original version provided only
            included files and simple string replacements: #include and #define of parameterless macros. Soon after
            that, it was extended, mostly by Mike Lesk and then by John Reiser, to incorporate macros with arguments and
            conditional compilation.[12]

            Unix was one of the first operating system kernels implemented in a language other than assembly. Earlier
            instances include the Multics system (which was written in PL/I) and Master Control Program (MCP) for the
            Burroughs B5000 (which was written in ALGOL) in 1961. In and around 1977, Ritchie and Stephen C. Johnson
            made further changes to the language to facilitate portability of the Unix operating system. Johnson's
            Portable C Compiler served as the basis for several implementations of C on new platforms.[21]</p>
        <hr>
        <p>The preprocessor was introduced around 1973 at the urging of Alan Snyder and also in recognition of the
            usefulness of the file-inclusion mechanisms available in BCPL and PL/I. Its original version provided only
            included files and simple string replacements: #include and #define of parameterless macros. Soon after
            that, it was extended, mostly by Mike Lesk and then by John Reiser, to incorporate macros with arguments and
            conditional compilation.[12]

            Unix was one of the first operating system kernels implemented in a language other than assembly. Earlier
            instances include the Multics system (which was written in PL/I) and Master Control Program (MCP) for the
            Burroughs B5000 (which was written in ALGOL) in 1961. In and around 1977, Ritchie and Stephen C. Johnson
            made further changes to the language to facilitate portability of the Unix operating system. Johnson's
            Portable C Compiler served as the basis for several implementations of C on new platforms.[21]</p>
        <hr>
        <p>K&R C

            The cover of the book The C Programming Language, first edition, by Brian Kernighan and Dennis Ritchie
            In 1978 Brian Kernighan and Dennis Ritchie published the first edition of The C Programming Language.[23]
            Known as K&R from the initials of its authors, the book served for many years as an informal specification
            of the language. The version of C that it describes is commonly referred to as "K&R C". As this was released
            in 1978, it is now also referred to as C78.[24] The second edition of the book[25] covers the later ANSI C
            standard, described below.

            K&R introduced several language features:

            Standard I/O library
            long int data type
            unsigned int data type
            Compound assignment operators of the form =op (such as =-) were changed to the form op= (that is, -=) to
            remove the semantic ambiguity created by constructs such as i=-10, which had been interpreted as i =- 10
            (decrement i by 10) instead of the possibly intended i = -10 (let i be ‚àí10).
            Even after the publication of the 1989 ANSI standard, for many years K&R C was still considered the "lowest
            common denominator" to which C programmers restricted themselves when maximum portability was desired, since
            many older compilers were still in use, and because carefully written K&R C code can be legal Standard C as
            well.

            Although later versions of C require functions to have an explicit type declaration, K&R C only requires
            functions that return a type other than int to be declared before use. Functions used without prior
            declaration were presumed to return int.</p>
        <hr>
        <p>The declaration of long_function() (on line 1) is required since it returns long; not int. Function
            int_function can be called (line 11) even though it is not declared since it returns int. Also, variable
            intvar does not need to be declared as type int since that is the default type for register keyword.

            Since function declarations did not include information about arguments, type checks were not performed,
            although some compilers would issue a warning if different calls to a function used different numbers or
            types of arguments. Tools such as Unix's lint utility were developed that (among other things) checked for
            consistency of function use across multiple source files.

            In the years following the publication of K&R C, several features were added to the language, supported by
            compilers from AT&T (in particular PCC[26]) and other vendors. These included:

            void functions; functions returning no value
            Functions returning struct or union types
            Assignment for struct variables
            Enumerated types
            The popularity of the language, lack of agreement on standard library interfaces, and lack of compliance to
            the K&R specification, led to standardization effort.</p>
        <hr>
        <p><b>ANSI C and ISO C</b></p>
        <p>Main article: ANSI C
            During the late 1970s and 1980s, versions of C were implemented for a wide variety of mainframe computers,
            minicomputers, and microcomputers, including the IBM PC, as its popularity increased significantly.</p>
        <p>n 1983 the American National Standards Institute (ANSI) formed a committee, X3J11, to establish a standard
            specification of C. X3J11 based the C standard on the Unix implementation; however, the non-portable portion
            of the Unix C library was handed off to the IEEE working group 1003 to become the basis for the 1988 POSIX
            standard. In 1989, the C standard was ratified as ANSI X3.159-1989 "Programming Language C". This version of
            the language is often referred to as ANSI C, Standard C, or sometimes C89.</p>
        <p>n 1990 the ANSI C standard (with formatting changes) was adopted by the International Organization for
            Standardization (ISO) as ISO/IEC 9899:1990, which is sometimes called C90. Therefore, the terms "C89" and
            "C90" refer to the same programming language.</p>
        <p>ANSI, like other national standards bodies, no longer develops the C standard independently, but defers to
            the international C standard, maintained by the working group ISO/IEC JTC1/SC22/WG14. National adoption of
            an update to the international standard typically occurs within a year of ISO publication.</p>
        <p>One of the aims of the C standardization process was to produce a superset of K&R C, incorporating many of
            the subsequently introduced unofficial features. The standards committee also included several additional
            features such as function prototypes (borrowed from C++), void pointers, support for international character
            sets and locales, and preprocessor enhancements. Although the syntax for parameter declarations was
            augmented to include the style used in C++, the K&R interface continued to be permitted, for compatibility
            with existing source code</p>
        <p>C89 is supported by current C compilers, and most modern C code is based on it. Any program written only in
            Standard C and without any hardware-dependent assumptions will run correctly on any platform with a
            conforming C implementation, within its resource limits. Without such precautions, programs may compile only
            on a certain platform or with a particular compiler, due, for example, to the use of non-standard libraries,
            such as GUI libraries, or to a reliance on compiler- or platform-specific attributes such as the exact size
            of data types and byte endianness.</p>
        <p>In cases where code must be compilable by either standard-conforming or K&R C-based compilers, the __STDC__
            macro can be used to split the code into Standard and K&R sections to prevent the use on a K&R C-based
            compiler of features available only in Standard C.</p>
        <p>After the ANSI/ISO standardization process, the C language specification remained relatively static for
            several years. In 1995, Normative Amendment 1 to the 1990 C standard (ISO/IEC 9899/AMD1:1995, known
            informally as C95) was published, to correct some details and to add more extensive support for
            international character sets.</p>
        <hr>
        <p><b>C99</b></p>
        <p>Main article: C99</p>
        <p>Main article: C99
            The C standard was further revised in the late 1990s, leading to the publication of ISO/IEC 9899:1999 in
            1999, which is commonly referred to as "C99". It has since been amended three times by Technical Corrigenda.
        </p>
        <p>C99 introduced several new features, including inline functions, several new data types (including long long
            int and a complex type to represent complex numbers), variable-length arrays and flexible array members,
            improved support for IEEE 754 floating point, support for variadic macros (macros of variable arity), and
            support for one-line comments beginning with //, as in BCPL or C++. Many of these had already been
            implemented as extensions in several C compilers.</p>
        <p>C99 is for the most part backward compatible with C90, but is stricter in some ways; in particular, a
            declaration that lacks a type specifier no longer has int implicitly assumed. A standard macro
            __STDC_VERSION__ is defined with value 199901L to indicate that C99 support is available. GCC, Solaris
            Studio, and other C compilers now[when?] support many or all of the new features of C99. The C compiler in
            Microsoft Visual C++, however, implements the C89 standard and those parts of C99 that are required for
            compatibility with C++11.[30][needs update]

            In addition, the C99 standard requires support for identifiers using Unicode in the form of escaped
            characters (e.g. \u0040 or \U0001f431) and suggests support for raw Unicode names.</p>
        <hr>
        <p><b>C11</b></p>
        <p>Work began in 2007 on another revision of the C standard, informally called "C1X" until its official
            publication of ISO/IEC 9899:2011 on December 8, 2011. The C standards committee adopted guidelines to limit
            the adoption of new features that had not been tested by existing implementations.

            The C11 standard adds numerous new features to C and the library, including type generic macros, anonymous
            structures, improved Unicode support, atomic operations, multi-threading, and bounds-checked functions. It
            also makes some portions of the existing C99 library optional, and improves compatibility with C++. The
            standard macro __STDC_VERSION__ is defined as 201112L to indicate that C11 support is available.</p>
        <p><b>C17</b></p>
        <p>Main article: C17</p>
        <p>C17 is an informal name for ISO/IEC 9899:2018, a standard for the C programming language published in June
            2018. It introduces no new language features, only technical corrections, and clarifications to defects in
            C11. The standard macro __STDC_VERSION__ is defined as 201710L to indicate that C17 support is available.
        </p>
        <p><b>C23</b></p>
        <p>Main article: C23</p>
        <p>C23 is an informal name for the current major C language standard revision and was known as "C2X" through
            most of its development. It builds on past releases, introducing features like new keywords, types including
            nullptr_t and _BitInt(N), and expansions to the standard library.[31] C23 was published in October 2024 as
            ISO/IEC 9899:2024.[32] The standard macro __STDC_VERSION__ is defined as 202311L to indicate that C23
            support is available.</p>
        <p><b>C2Y</b></p>
        <p>Main article: C2Y</p>
        <p>Main article: C2Y C2Y is an informal name for the next major C language standard revision, after C23 (C2X),
            that is hoped to be released later in the 2020s, hence the '2' in "C2Y". An early working draft of C2Y was
            released in February 2024 as N3220 by the working group ISO/IEC JTC1/SC22/WG14</p>
        <hr>
        <p><b>Embedded C</b></p>
        <p>Main article: Embedded C</p>
        <p>Historically, embedded C programming requires non-standard extensions to the C language to support exotic
            features such as fixed-point arithmetic, multiple distinct memory banks, and basic I/O operations. In 2008,
            the C Standards Committee published a technical report extending the C language[34] to address these issues
            by providing a common standard for all implementations to adhere to. It includes a number of features not
            available in normal C, such as fixed-point arithmetic, named address spaces, and basic I/O hardware
            addressing.</p>
    </section>
    <section class="about-course">
        <p><b>Definition</b></p>
        <hr>
        <p>Main article: C (programming language) syntax</p>
        <p>C has a formal grammar specified by the C standard.[35] Line endings are generally not significant in C;
            however, line boundaries do have significance during the preprocessing phase. Comments may appear either
            between the delimiters /* and */, or (since C99) following // until the end of the line. Comments delimited
            by /* and */ do not nest, and these sequences of characters are not interpreted as comment delimiters if
            they appear inside string or character literals</p>
        <p>C source files contain declarations and function definitions. Function definitions, in turn, contain
            declarations and statements. Declarations either define new types using keywords such as struct, union, and
            enum, or assign types to and perhaps reserve storage for new variables, usually by writing the type followed
            by the variable name. Keywords such as char and int specify built-in types. Sections of code are enclosed in
            braces ({ and }, sometimes called "curly brackets") to limit the scope of declarations and to act as a
            single statement for control structures.</p>
        <p>As an imperative language, C uses statements to specify actions. The most common statement is an expression
            statement, consisting of an expression to be evaluated, followed by a semicolon; as a side effect of the
            evaluation, functions may be called and variables assigned new values. To modify the normal sequential
            execution of statements, C provides several control-flow statements identified by reserved keywords.
            Structured programming is supported by if ... [else] conditional execution and by do ... while, while, and
            for iterative execution (looping). The for statement has separate initialization, testing, and
            reinitialization expressions, any or all of which can be omitted. break and continue can be used within the
            loop. Break is used to leave the innermost enclosing loop statement and continue is used to skip to its
            reinitialisation. There is also a non-structured goto statement, which branches directly to the designated
            label within the function. switch selects a case to be executed based on the value of an integer expression.
            Different from many other languages, control-flow will fall through to the next case unless terminated by a
            break.</p>
        <p>Expressions can use a variety of built-in operators and may contain function calls. The order in which
            arguments to functions and operands to most operators are evaluated is unspecified. The evaluations may even
            be interleaved. However, all side effects (including storage to variables) will occur before the next
            "sequence point"; sequence points include the end of each expression statement, and the entry to and return
            from each function call. Sequence points also occur during evaluation of expressions containing certain
            operators (&&, ||, ?: and the comma operator). This permits a high degree of object code optimization by the
            compiler, but requires C programmers to take more care to obtain reliable results than is needed for other
            programming languages.</p>
        <p>Kernighan and Ritchie say in the Introduction of The C Programming Language: "C, like any other language,
            has its blemishes. Some of the operators have the wrong precedence; some parts of the syntax could be
            better."[37] The C standard did not attempt to correct many of these blemishes, because of the impact of
            such changes on already existing software.</p>
        <p><b>Character Set</b></p>
        <p>The basic C source character set includes the following characters:</p>
        <li>Lowercase and uppercase letters of the ISO basic Latin alphabet: a‚Äìz, A‚ÄìZ</li>
        <li>Digits: 0‚Äì9</li>
        <li>Graphic characters: ! " # % & ' ( ) * + , - . / : ; <=> ? [ \ ] ^ _ { | } ~</li>
        <p>The newline character indicates the end of a text line; it need not correspond to an actual single character,
            although for convenience C treats it as such.</p>
        <p>The POSIX standard mandates a portable character set which adds a few characters (notably "@") to the basic C
            source character set. Both standards do not prescribe any particular value encoding‚ÄîASCII and EBCDIC both
            comply with these standards, since they include at least those basic characters, even though they use
            different encoded values for those characters</p>
        <p>Additional multi-byte encoded characters may be used in string literals, but they are not entirely portable.
            Since C99 multi-national Unicode characters can be embedded portably within C source text by using \uXXXX or
            \UXXXXXXXX encoding (where X denotes a hexadecimal character).</p>
        <p>The basic C execution character set contains the same characters, along with representations for the null
            character, alert, backspace, and carriage return</p>
        <p>Run-time support for extended character sets has increased with each revision of the C standard.</p>
        <p><b>Reserved words</b></p>
        <p>All versions of C have reserved words that are case sensitive. As reserved words, they cannot be used for
            variable names.</p>
        <p>C89 has 32 reserved words:</p>
        <li>auto</li>
        <li>break</li>
        <li>case</li>
        <li>char</li>
        <li>const</li>
        <li>continue</li>
        <li>default</li>
        <li>do</li>
        <li>double</li>
        <li>else</li>
        <li>enum</li>
        <li>extern</li>

        <li>float</li>
        <li>for</li>
        <hr>
        <li>int</li>
        <li>long</li>
        <li>register</li>
        <li>return</li>
        <li>short</li>
        <li>signed</li>
        <li>sizeof</li>
        <li>static</li>
        <li>struct</li>
        <li>switch</li>
        <li>typedef</li>
        <li>union</li>
        <li>unsigned</li>
        <li>void</li>
        <li>volatile</li>
        <li>while</li>

        <p>C99 added five more reserved words: (‚Ä° indicates an alternative spelling alias for a C23 keyword)</p>
        <li>inline</li>
        <li>restrict</li>
        <li>_Bool ‚Ä°</li>
        <li>_Complex</li>
        <li>_Imaginary</li>
        <p>C11 added seven more reserved words:[39] (‚Ä° indicates an alternative spelling alias for a C23 keyword)</p>
        <li>_Alignas ‚Ä°</li>
        <li>_Alignof ‚Ä°</li>
        <li>_Atomic</li>
        <li>_Generic</li>
        <li>_Noreturn ‚Ä°</li>
        <li>_Static_assert ‚Ä°</li>
        <li>_Thread_local ‚Ä°</li>
        <p>C23 added fourteen more reserved words:</p>
        <li>alignas</li>
        <li>alignof</li>
        <li>bool</li>
        <li>constexpr</li>
        <li>fulse</li>
        <li>nullptr</li>
        <li>static_assert</li>
        <li>thread_local</li>
        <li>true</li>
        <li>typeof</li>
        <li>typeof_unequl</li>
        <li>_bitInt</li>
        <li>_Decimal132</li>
        <li>_Decimal162</li>
        <li>_Decimal128</li>


        <p>Most of the recently reserved words begin with an underscore followed by a capital letter, because
            identifiers of that form were previously reserved by the C standard for use only by implementations. Since
            existing program source code should not have been using these identifiers, it would not be affected when C
            implementations started supporting these extensions to the programming language. Some standard headers do
            define more convenient synonyms for underscored identifiers. Some of those words were added as keywords with
            their conventional spelling in C23 and the corresponding macros were removed.</p>
        <p>Prior to C89, entry was reserved as a keyword. In the second edition of their book The C Programming
            Language, which describes what became known as C89, Kernighan and Ritchie wrote, "The ... [keyword] entry,
            formerly reserved but never used, is no longer reserved." and "The stillborn entry keyword is withdrawn."
        </p>
        <p>
            <b>Operators</b>
        </p>
        <p>Main article: Operators in C and C++</p>
        <p>C supports a rich set of operators, which are symbols used within an expression to specify the manipulations
            to be performed while evaluating that expression. C has operators for:</p>
        <li>Arithmetic +, -, *, /, %</li>
        <li>assignment: =
        </li>
        <li>augmented assignment: +=, -=, *=, /=, %=, &=, |=, ^=, <<=,>>=</li>
        <li>bitwise logic: ~, &, |, ^</li>
        <li>bitwise shifts: <<,>></li>
        <li>Boolean logic: !, &&, ||</li>
        <li>conditional evaluation: ? :</li>
        <li>equality testing: ==, !=
        </li>
        <li>calling functions: ( )</li>
        <li>increment and decrement: ++, --</li>
        <li>member selection: ., ->
        </li>type conversion: (typename)
        <li>object size: sizeof</li>
        <li>type: typeof, typeof_unqual since C23</li>
        <li>order relations: <, <=,>, >=
        </li>
        <li>reference and dereference: &, *, [ ]</li>
        <li>sequencing: ,</li>
        <li>subexpression grouping: ( )</li>
        <li>type conversion: (typename)</li>

        <p>C uses the operator = (used in mathematics to express equality) to indicate assignment, following the
            precedent of Fortran and PL/I, but unlike ALGOL and its derivatives. C uses the operator == to test for
            equality. The similarity between the operators for assignment and equality may result in the accidental use
            of one in place of the other, and in many cases the mistake does not produce an error message (although some
            compilers produce warnings). For example, the conditional expression if (a == b + 1) might mistakenly be
            written as if (a = b + 1), which will be evaluated as true unless the value of a is 0 after the assignment.
        </p>
        <p>The C operator precedence is not always intuitive. For example, the operator == binds more tightly than (is
            executed prior to) the operators & (bitwise AND) and | (bitwise OR) in expressions such as x & 1 == 0, which
            must be written as (x & 1) == 0 if that is the coder's intent.[</p>
        <p><b>Data types</b></p>
        <p>In the C programming language, data types define the type of data a variable can store. They tell the
            compiler how much memory to allocate for a variable and what kind of operations can be performed on it.
            Every variable in C must be declared with a data type before it is used. Proper use of data types improves
            program efficiency, memory management, and code readability.</p>
        <p>C is a statically typed language, meaning data types are checked at compile time. C provides a rich set of
            data types that are broadly classified into Basic (Primitive), Derived, Enumeration, and Void data types.
        </p>
        <p>1. Basic (Primitive) Data Types
            Basic data types are the fundamental data types provided by C. They store simple values such as integers,
            characters, and floating-point numbers.</p>
        <p><b>1.1 int</b>
            <hr>
            The int data type is used to store integer values (whole numbers without decimal points).

            Example:int age = 20;
        </p>
        <li>Size: Usually 4 bytes (depends on compiler)</li>
        <li>Range: ‚àí32,768 to 32,767 (for 2-byte) or larger for 4-byte</li>
        <li>Used for counting, indexing, and arithmetic operations</li>
        <p><b>Variants of int:</b></p>
        <li>short int </li>

        <li>long int</li>

        <li>long long int</li>

        <li>signed int</li>

        <li>unsigned int</li>
        <p> <b>1.2 char</b>
            <hr>
            The char data type stores a single character such as letters, digits, or symbols.
        </p>
        <li>Size: 1 byte </li>
        <li>Range: </li>
        <li>signed char: ‚àí128 to 127</li>
        <li>unsigned char: 0 to 255</li>

        <li>Stored using ASCII values</li>
        <p><b>1.3 float</b>
            <hr>
            The float data type stores decimal (real) numbers with single precision.

            Example:

            float price = 99.99;
        </p>
        <li>Size: 4 bytes </li>

        <li>Precision: Up to 6 decimal places</li>

        <li>Used where memory efficiency is important</li>
        <p></p>
        <p><b>1.4 double </b>
            <hr>
            The double data type stores decimal numbers with double precision, providing more accuracy than float.

            Example:

            double pi = 3.1415926535;
            <li>Size: 8 bytes</li>

            <li>Precision: Up to 15 decimal places</li>

            <li>Used in scientific and mathematical calculations</li>
        </p>
        <p><b>1.5 void </b>
            <hr>

            The void data type represents no value. It is mainly used in functions.

            Example:

            void display() {
            printf("Hello");
            }
            Uses of void:

            <li>Function returning no value</li>

            <li>Function with no parameters</li>

            <li>Generic pointer (void *)</li>

        </p>
        <p><b>2. Derived Data Types </b>
            <hr>
        <p> Derived data types are formed using basic data types.</p>

        <p><b>2.1 Array</b></p><br>
        <p>An array stores multiple values of the same data type in a contiguous memory location.

            Example:

            int marks[5] = {80, 75, 90, 85, 70};</p>
        <li>Elements are accessed using index</li>
        <li>Index starts from 0</li>
        <li>Efficient for storing collections of similar data</li>

        <p><b>2.2 Pointer</b></p>
        <hr>
        <p>A pointer stores the memory address of another variable.

            Example:

            int a = 10;
            int *p = &a;</p>
        <li>Powerful feature of C</li>

        <li>Used in dynamic memory allocation, arrays, and functions</li>

        <li>Improves performance by avoiding data copying</li>


        <p><b>2.3 Structure</b></p>
        <hr>
        <p> A structure allows grouping different data types under one name.

            Example:

            struct student {
            int roll;
            char name[20];
            float marks;
            };</p>
        <li>Used to represent real-world entities</li>

        <li>Each element is called a member</li>

        <li>Helps in organizing complex data</li>

        <p><b>2.4 Union</b></p>
        <hr>
        <p>A union is similar to a structure, but all members share the same memory location.

            Example:

            union data {
            int i;
            float f;
            char c;
            };</p>
        <li>Memory efficient</li>

        <li>Only one member can be used at a time</li>

        <li>Size equals the largest member</li>

        <p><b>3. Enumeration (enum)</b></p>
        <hr>
        <p>Enumeration is a user-defined data type that assigns names to integer constants.

            Example:

            enum day {Mon, Tue, Wed, Thu, Fri, Sat, Sun};</p>
        <li>Improves code readability</li>

        <li>Values start from 0 by default</li>

        <li>Used for fixed sets of values</li>

        <p><b>4. Type Modifiers</b></p>
        <hr>
        <p>Type modifiers change the size or range of basic data types.</p>
        </li>
        <li> Common modifiers:</p>li>
        <li> short</li>
        <li> long</li>
        <li> signed</li>

        <li> unsigned</li>

        <p>Example:

            unsigned int count;
            long double value;
        </p>
        <p><b>5. Type Qualifiers</b></p>
        <hr>
        <p>Type qualifiers specify special properties of variables.</p>

        <p><b>5.1 const</b></p><br>
        <p>Prevents modification of a variable.</p>

        <p>const int MAX = 100;</p>
        <p><b>5.2 volatile</b></p><br>
        <p>Tells compiler that value may change unexpectedly.</p>

        <p>volatile int flag;</p>
        <p><b>6. User-Defined Data Types</b></p>
        <hr>
        <p></p>C allows programmers to create their own data types.</p>

        <p><b>6.1 typedef</b></p><br>
        <p>Creates an alias for an existing data type.</p>

        <p>typedef unsigned int uint;</p>
        <hr>
        <p>7. Size of Data Types</p>
        <p> Data Type Size (Bytes)
            char 1
            int 4
            float 4
            double 8
            long double 16</p>
        <p> (Size may vary depending on compiler and system)</p>
        <p></p>

    </section>








    <!-- ===== FOOTER ===== -->
    <footer>
        <p>¬© 2025 Programming World. All rights reserved.</p>
        <div class="social">
            <a href="#"><img src="https://cdn-icons-png.flaticon.com/512/733/733547.png" alt="Facebook"></a>
            <a href="#"><img src="https://cdn-icons-png.flaticon.com/512/2111/2111463.png" alt="Instagram"></a>
            <a href="#"><img src="https://cdn-icons-png.flaticon.com/512/174/174857.png" alt="LinkedIn"></a>
        </div>
    </footer>



</body>
<script src="../js/index.js"></script>
<script src="../js/dropdown.js"></script>
<script src="../js/changeble_search_placeeholder.js"></script>


</html>